## Задание 1 (task_1.py)

Допущения: 
1. Сортировка в файле не меняется.
2. Поле Data уникальное.

# 1.1 Метод "в лоб".

Создаем копию файла до обновления и после обновления сравниваем 2 файла построчно. После обновления заменяем старую копию. 

Преимущества: 
- относительная простота, 
- мин. технологий задействовано,
- быстро, если сортировка файле не меняется, а добавляются только строки.

Недостатки: 
- если сортировка меняется, то скорость будет низкой и будет снижаться с ростом файла,
- если надо хранить еще и историю, нужно создавать дополнительные файлы - неудобная структура для хранения.

Результаты работы алгоритма (объем файла 10^5 строк):
- копирование файла - 3.4740 мс
- сравнение файлов - 43.6244 мс


# 1.2 Поиск через БД 
Столбец Data делаем с уникальным значением. 
Добавляем столбец Date с датой добавления нового значения.
При обновлении значений добавляем новые значения с текущей датой.

При обновлении дублирующиеся значения записываться не будут, новые знаения попадут с датой обновления.

Недостатки:
- реализация исключения добавления уже имеющихся значений (в зависимости от БД)
- необходимость создать и поддерживать БД,
- при обновлении БД требуется проходится по всему файлу, но 1 раз,

Преимущества:
- высокая скорость получения данных (по сути, один SQL запрос),
- много времени занимает первоначальное внесение файла, последующее обновление - на порядок меньше,
- больше подходит для последующей работы с данными,

Результаты работы алгоритма (объем файла 10^5 строк, SQLite3):
- запись файла в базу данных - 516541.7709 мс
- обновление базы данных - 4038.0487 мс

Можно повысить скорость используя высокопроизводительную БД, но пока это самый медленный способ.


# 1.3 Git

Использовать инкрементную систему контроля изменений в фалах, типа Git.

Версию файла до обновления коммитим и сравниваем обновленный файл с последним коммитом.
'''
git init
git add initial.csv
git commit -m "update"
'''
после обновления в командной строке получаем файл с новыми строками:
'''
git diff | grep '^\+[^+]' | cut -c 2- > git_changes.csv
'''
Дальше коммитим новый файл и т.д.


Преимущества:
- самое быстрое решение, если сортировка строк будет меняться,
- готовая система контроля версий,
- занимает мало места, т.к. хранит только изменения,
- больше подходит для отслеживания изменений,

Недостатки:
- не самое удобное решение для постоянной работы с файлом, необходимо работать через командную строку или сторонние библиотеки.

Результаты работы алгоритма (объем файла 10^5):
- коммит файла - 117,4986 мс
- обновление базы данных - 63,0562 мс


Рейтинг:
1. Способ 3 (Git). Время работы:  180 мс
2. Способ 2 (DB). Время работы: 4038 мс (только добавление новых строк и их вывод)
3. Способ 1 (сравнение файлов в python). Время работы: 47 мс.

Хоть использование Git и уступает 1 способу по скорости, но опережает при изменении сортировки, а также имеет широкий функционал, который потом можно подключить. Для постоянной работы лучше использовать базу данных.

Код в приложении запускается с ключами, посмотреть ключи можно по ключу -h.

## Задание 2 (task_2.py)

Код в приложении запускается с ключами, посмотреть ключи можно по ключу -h. Ключ -t выводит список типов, -s "имя типа" - список данных по этому типу.



